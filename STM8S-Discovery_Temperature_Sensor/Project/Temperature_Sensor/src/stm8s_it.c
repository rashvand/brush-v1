/**
  ******************************************************************************
  * @file Temperature_Sensor_example\stm8s_it.c
  * @brief This file contains the interrupt vectors table and interrupt routines
	*        for the temperature sensor example on STM8S-Discovery.
  * @author STMicroelectronics, MCD Application Team
  * @version 1.0
  * @date 30-MAR-2010
  ******************************************************************************
  *
  * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  * FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  *
  * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
  * @image html logo.bmp
  ******************************************************************************
  */
/* Includes ------------------------------------------------------------------*/
#include "stm8s.h"
#include "shared_elements.h"

/**
  * @addtogroup Temperature_Sensor__Example
  * @{
  */

/* Public variables ---------------------------------------------------------*/

/* button event flags */
bool ButtonPressed1 = FALSE;
bool ButtonPressed2 = FALSE;

/* Private functions --------------------------------------------------------*/

#ifdef _COSMIC_			/* COSMIC compiler */

typedef void @far (*interrupt_handler_t)(void);

struct interrupt_vector {
	unsigned char interrupt_instruction;
	interrupt_handler_t interrupt_handler;
};

/**
  * @brief Dummy interrupt routine
  * @par Parameters:
  * None
  * @retval
  * None
*/
@far @interrupt void NonHandledInterrupt (void)
{
	/* in order to detect unexpected events during development, 
	   it is recommended to set a breakpoint on the following instruction
	*/
	return;
}

/**
  * @brief PORTB interrupt routine
  * @par Parameters:
  * None
  * @retval
  * None
*/
@far @interrupt void PORTA_IRQHandler (void)
{
	if( !(GPIOA->IDR & 0x08) )
		ButtonPressed1 = TRUE;	
	else if( !(GPIOA->IDR & 0x10) )
		ButtonPressed2 = TRUE;
}

/**
  * @brief TIM3 interrupt routine
  * @par Parameters:
  * None
  * @retval
  * None
*/
@far @interrupt void TIM3_IRQHandler (void)
{
	/*This interrupt routine is executed after every 50ms approx*/
	
	/* Interrupt generated by UIF */
	if( no_of_sample_vals < MAX_NO_SAMPLE_VAL )	//If MAX NO OF SAMPLES are taken then temperature
	{                                            //values will not be recorded in array temp_arr
		ADC1->CR1 |= ADC1_CR1_ADON;		//ADC powered up
		ADC1->CR1 |= ADC1_CR1_ADON;		//begin conversion	
		
		while (!(ADC1->CSR & ADC1_CSR_EOC)){}; //check for the EOC
		
		temp_arr[no_of_sample_vals] = ADC1->DRL;					//must read LSBs first
		temp_arr[no_of_sample_vals++] |= ADC1->DRH << 8;
		
		ADC1->CR1 |= ~ADC1_CR1_ADON;	//ADC powered down
	}

	TIM3->SR1 &= ~TIM3_SR1_UIF;   /* Clear UIF flag */
	
	TRtc_CntUpdate();            /* Function for updating the counters */	       	                      
}

/* startup routine */
extern void _stext();     

/* interrupt vectors table */
struct interrupt_vector const _vectab[] = {
	{0x82, (interrupt_handler_t)_stext}, /* reset */
	{0x82, NonHandledInterrupt}, /* trap  */
	{0x82, NonHandledInterrupt}, /* irq0  */
	{0x82, NonHandledInterrupt}, /* irq1  */
	{0x82, NonHandledInterrupt}, /* irq2  */
	{0x82, (interrupt_handler_t)PORTA_IRQHandler}, /* irq3  */
	{0x82, NonHandledInterrupt}, /* irq4  */
	{0x82, NonHandledInterrupt}, /* irq5  */
	{0x82, NonHandledInterrupt}, /* irq6  */
	{0x82, NonHandledInterrupt}, /* irq7  */
	{0x82, NonHandledInterrupt}, /* irq8  */
	{0x82, NonHandledInterrupt}, /* irq9  */
	{0x82, NonHandledInterrupt}, /* irq10 */
	{0x82, NonHandledInterrupt}, /* irq11 */
	{0x82, NonHandledInterrupt}, /* irq12 */
	{0x82, NonHandledInterrupt}, /* irq13 */
	{0x82, NonHandledInterrupt}, /* irq14 */
	{0x82, (interrupt_handler_t)TIM3_IRQHandler}, /* irq15  */
	{0x82, NonHandledInterrupt}, /* irq16 */
	{0x82, NonHandledInterrupt}, /* irq17 */
	{0x82, NonHandledInterrupt}, /* irq18 */
	{0x82, NonHandledInterrupt}, /* irq19 */
	{0x82, NonHandledInterrupt}, /* irq20 */
	{0x82, NonHandledInterrupt}, /* irq21 */
	{0x82, NonHandledInterrupt}, /* irq22 */
	{0x82, NonHandledInterrupt}, /* irq23 */
	{0x82, NonHandledInterrupt}, /* irq24 */
	{0x82, NonHandledInterrupt}, /* irq25 */
	{0x82, NonHandledInterrupt}, /* irq26 */
	{0x82, NonHandledInterrupt}, /* irq27 */
	{0x82, NonHandledInterrupt}, /* irq28 */
	{0x82, NonHandledInterrupt}, /* irq29 */
};

#else /* Raisonance */

/**
  * @brief TRAP interrupt routine
  * @par Parameters:
  * None
  * @retval
  * None
*/
void TRAP_IRQHandler(void) trap
{
  /* In order to detect unexpected events during development,
     it is recommended to set a breakpoint on the following instruction.
  */
}

/**
  * @brief PORTA interrupt routine
  * @par Parameters:
  * None
  * @retval
  * None
*/
void PORTA_IRQHandler(void) interrupt 3
{
	if( !(GPIOA->IDR & 0x08) )
		ButtonPressed1 = TRUE;
	else if( !(GPIOA->IDR & 0x10) )
		ButtonPressed2 = TRUE;
}

/**
  * @brief TIM3 interrupt routine
  * @par Parameters:
  * None
  * @retval
  * None
*/
void TIM3_IRQHandler (void) interrupt 15
{
	/*This interrupt routine is executed after every 50ms approx*/
	
	/* Interrupt generated by UIF */
	if( no_of_sample_vals < MAX_NO_SAMPLE_VAL )	//If MAX NO OF SAMPLES are taken then temperature
	{                                            //values will not be recorded in array temp_arr
		ADC1->CR1 |= ADC1_CR1_ADON;		//ADC powered up
		ADC1->CR1 |= ADC1_CR1_ADON;		//begin conversion	
		
		while (!(ADC1->CSR & ADC1_CSR_EOC)){}; //check for the EOC
		
		temp_arr[no_of_sample_vals] = ADC1->DRL;					//must read LSBs first
		temp_arr[no_of_sample_vals++] |= ADC1->DRH << 8;
		
		ADC1->CR1 |= ~ADC1_CR1_ADON;	//ADC powered down
	}

	TIM3->SR1 &= ~TIM3_SR1_UIF;   /* Clear UIF flag */
	
	TRtc_CntUpdate();            /* Function for updating the counters */		     	                       
}

#endif	/* _COSMIC_ */
/**
  * @}
  */

/******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/
